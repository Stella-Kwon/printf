.SUFFIXES = .c .o

NAME = libftprintf.a

SRCS = $(wildcard *.c)
OBJS = $(patsubst %.c,%.o,$(wildcard *.c)) 
CC = cc 
ALL = $(wildcard *.o)
#.o파일이 extract되지 않은상태에서 tester 파일로 들어가면 인식이 안되서 컴파일이안돼...
#$(SRCS:.c=.o) wildcard를 사용해서 scrs를 정해줬을때는 옆에처럼 적으면 .o로 바껴서 적히지 않음.

CFLAGS = -Wall -Werror -Wextra -c -g

# 동적라이브러리 만들때 gcc로 
#Lib = -Llibft -llibft or -wl,-rpath,.........?
#use of -l/-L https://www.rapidtables.com/code/linux/gcc/gcc-l.html
# good description. https://stackoverflow.com/questions/3821916/how-to-merge-two-ar-static-libraries-into-one
#https://hyeonbell.tistory.com/132
INCLUDE = -I ./ft_printf.h 
#if you call the header files in every file then it will detect even without calling INCLUDE

#target … : prerequisites …
#        recipe
#A target is usually the name of a file that is generated by a program; examples of targets are executable or object files. A target can also be the name of an action to carry out, such as ‘clean’ (see Phony Targets).

#A prerequisite is a file that is used as input to create the target. A target often depends on several files.

#A recipe is an action that make carries out. A recipe may have more than one command, either on the same line or each on its own line. Please note: you need to put a tab character at the beginning of every recipe line! This is an obscurity that catches the unwary. If you prefer to prefix your recipes with a character other than tab, you can set the .RECIPEPREFIX variable to an alternate character (see Special Variables).
all: subsystem $(NAME)

subsystem:
#	cd libft; $(MAKE)
#	cd libft && $(MAKE)
	cd libft; make all
#$(make) = make 매크로인듯.
$(NAME):
##	$(CC) $(CFLAGS) $(INCLUDE) $(SRCS)
#	ls -l 
#	@echo "NO ar"
##	ar rc $@ $(OBJS) and later whter ar -rcs change to : ar -rus	$@ $(wildcard *.o)
#	@echo "libftprintf.a"
#	ar -t libft/libft.a = this will list all the compiled files in libft.a := ls function
##	ar -xv libft/libft.a //////////------중요한 단점이 이러면 .h파일 까지 포함해지지 않기때문에 나중에 컴파일시 라이브러리를 불러서 사용할수 없다고 뜸. 그래서 컴파일이 안됌.
#-x extract .o file from .a file.
##	ls -l 
#	@echo "extract"
##	$(CC) $(CFLAGS) $(INCLUDE) $(SRCS)
##	ar -rus	$@ $(OBJS)
#	@echo "done"
#ranlib $@
#--------------------------위에꺼 무용지물이었음.ㅋㅋ


# -----------tester로 넘어갈때 .o인식이 안되서, .a파일을 아에 옮겨서 업데이트시키는 방식으로. 밑의 예와 같음.
	mv ./libft/libft.a ./$(NAME) 
#	mv = when you make file again after make all, it will recreate .o file again to make libft.a as it moved out, so it doesnt exit any more.
	$(CC) $(CFLAGS) $(INCLUDE) $(SRCS)
	ar -rus $@ $(OBJS)

clean:
	make -C ./libft clean
#	rm -rf $(OBJS) 인식이 안되서 안지워짐. 이미 .o파일만 있기에
	rm -rf $(ALL)

fclean: clean
	make -C ./libft fclean
	rm -rf $(NAME)
#	cd ./libft; make fclean

re: fclean all

.PHONY: all clean fclean re libft


#-------------------------------------------------------------------------------------------
#you can do it as copy or mv the libft.a from the folder and add it.

#NAME = libftprintf.a
#SRCS = ft_printf.c ft_printf_utils.c ft_printf_ptr.c ft_printf_hex.c
#OBJS = $(SRCS:.c=.o)
#INCLUDE = libft/libft.h
#CFLAGS = -c -Wall -Wextra -Werror

#all: $(NAME)

#$(NAME):
#	make -C ./libft all 
# = cd libft; make all = cd libft; $(MAKE)
#	make -C ./libft bonus
#	mv ./libft/libft.a ./$(NAME)
#	cc $(CFLAGS) $(SRCS) -I $(INCLUDE)
#	ar -rus $(NAME) $(OBJS)

#clean:
#	make -C ./libft clean
#	rm -f $(OBJS) $(BONUS_OBJS)

#fclean: clean
#	make -C ./libft fclean
#	rm -f $(NAME)
#	rm -f libft.a

#re: fclean all

#.PHONY: all clean fclean re libft
