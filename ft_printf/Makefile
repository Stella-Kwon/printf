.SUFFIXES = .c .o

NAME = libftprintf.a

SRCS = $(wildcard *.c) 
#YOU SHOULD SPECIFY IT INCASE OF MOULINETTE WILL BAN YOU TOO.
OBJS = $(patsubst %.c,%.o,$(wildcard *.c)) 
CC = cc 
#ALL = $(wildcard *.o)
#.o파일이 extract되지 않은상태에서 tester 파일로 들어가면 인식이 안되서 컴파일이안돼...
#$(SRCS:.c=.o) wildcard를 사용해서 scrs를 정해줬을때는 옆에처럼 적으면 .o로 바껴서 적히지 않음.

CFLAGS = -Wall -Werror -Wextra -c

# 동적라이브러리 만들때 gcc로 
#Lib = -Llibft -llibft or -wl,-rpath,.........?
#use of -l/-L https://www.rapidtables.com/code/linux/gcc/gcc-l.html
# good description. https://stackoverflow.com/questions/3821916/how-to-merge-two-ar-static-libraries-into-one
#https://hyeonbell.tistory.com/132
INCLUDE = -I ./ft_printf.h 
#if you call the header files in every file then it will detect even without calling INCLUDE
헤더 파일(header file)은 C/C++ 프로그래밍 언어에서 함수, 변수, 구조체 등의 선언문을 포함하는 파일입니다.
이 파일을 사용하면 소스 파일에서 함수나 변수를 사용할 때 함수나 변수의 선언문을 따로 작성할 필요 없이, 헤더 파일에 선언된 함수나 변수를 사용할 수 있다.
소스 파일이 헤더 파일을 인클루드 하면, 헤더 파일에 정의된 선언문들을 컴파일러가 이해할 수 있도록 포함시켜주기 때문에 헤더 파일을 사용하면 코드의 재사용성과 가독성을 높일 수 있다.

추가로, 헤더파일로 분리하는 것도 컴파일 속도를 향상시키는 이점이 있다. 이는, 헤더파일만 변경되면 헤더파일만 컴파일하면 되기 때문이다.
*****************************************************
#but WITH OUT MOVING OR COPYING YOU CAN DIRECTLY ADD  -libft.a file you can do like:

$(TARGET) :
        $(CXX) -c $(SRCS) $(INC) $(LIB_DIRS) $(LIBS)
$(TARGET) 규칙을 풀어 보면 g++ -c main.cpp -I./include -L./lib -lprint 이다.
#추가적으로 더 사용할 라이브러리들은 -lprint 뒤에 -lXX -lXX 로 추가하면 된다. 이때 앞에 -L에서 명시해준 폴더와는 다른 폴더에 있을경우,
#다시 명시해줘야함
#즉
#cc  -o test.c test1.c -L/lib -lm -L. -lft.a 이렇게 해줘야되고
#cc  -o test.c test1.c -L/lib -lm -lft 같은폴더에 있을시에는 이렇게 해주면됌.
##https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=muri1004&logNo=220683116239. 참조
#--------------
#makefile 에서 -L과 -I 차이
#-L 옵션은 링크 타임에 사용되며, 컴파일러에게 라이브러리 경로를 알려줍니다. 예를 들어, -L/usr/local/lib 옵션은 /usr/local/lib 디렉토리에서 라이브러리를 찾을 것을 컴파일러에게 알려줍니다.
#-I 옵션은 컴파일 타임에 사용되며, 컴파일러에게 헤더 파일 경로를 알려줍니다. 예를 들어, -I/usr/local/include 옵션은 /usr/local/include 디렉토리에서 헤더 파일을 찾을 것을 컴파일러에게 알려줍니다.
#-L. 옵션은 컴파일러에게 현재 디렉토리에서 라이브러리를 찾을 것을 알려줍니다. "."은 현재 디렉토리를 의미합니다.
#예를들어 :
#gcc -L. -lmylib -o test test.c
#위 예제는 현재 디렉토리에서 libmylib.so 라이브러리를 찾아내서 test.c 파일에 링크하라는 의미를 가지고 있습니다.
#또한, 개발자들이 테스트 하는 경우 현재 개발 디렉토리에 있는 라이브러리 파일들을 링크하기 위해서도 사용할 수 있습니다.

#-L 다음에 나오는 -ㅣ은 어떻게 사용하나요
#-L 옵션 뒤에 -l 옵션이 나오면 컴파일러에게 해당 라이브러리를 링크할 것을 요청합니다. 
#-l 옵션 뒤에는 라이브러리 이름(예: -lm)이 나오며, 컴파일러는 해당 라이브러리를 링크할 것입니다.
#예를들어 :
#gcc -L/usr/local/lib -lm -o test test.c
#위 예제는 /usr/local/lib 디렉토리에서 libm.so 라이브러리를 찾아내서 test.c 파일에 링크하라는 의미를 가지고 있습니다.
#----------------------------------
#.so (Shared Object) 파일과 .a (Archive) 파일은 두 가지 종류의 라이브러리 파일입니다.

#.so 파일은 다른 프로그램에서 공유할 수 있는 동적 라이브러리(Dynamic Library) 입니다. 다른 프로그램이 해당 라이브러리를 호출하면, OS가 메모리에 올려서 사용할 수 있도록 해주며, 이때 공유되는 메모리 영역도 최소화 할 수 있다.

#.a 파일은 정적 라이브러리(Static Library) 입니다. 이는 프로그램이 실행될 때, 미리 라이브러리를 링크해서 같이 실행되는 형식입니다. 따라서 프로그램이 실행될 때마다 라이브러리를 불러올 필요가 없어지고, 프로그램 실행 속도를 높일 수 있지만 프로그램 용량이 커지게 됩니다.

#.so 파일은 메모리 효율적이지만, 프로그램 용량은 작게 유지하며 .a 파일은 프로그램 용량은 커지지지만, 실행속도를 높일수있다.

#"프로그램 용량"이란, 프로그램이 컴퓨터에 설치되거나 실행되는 동안 사용되는 메모리 크기를 의미합니다. 이 값은 프로그램이 얼마나 많은 메모리를 사용하며, 얼마나 많은 메모리 공간을 차지하는지를 나타냅니다. 프로그램의 용량이 크면, 
#컴퓨터에 설치되는 메모리 공간이 많이 차지하게 되며, 실행 속도도 저하될 수 있습니다.

##############################3
동적 라이브러리는 실행 시점에 로드되며, 실행 시점에 필요한 부분만 메모리에 로드하기 때문에 메모리 사용량을 절약할 수 있다.
정적 라이브러리는 컴파일 시점에 로드되며, 실행 파일에 포함되어 있기 때문에 실행 시점에 로드할 필요가 없다.
따라서 동적 라이브러리는 실행 파일 크기를 줄이고 실행 시점에 필요한 라이브러리만 가져오게하는 경우 사용하면 좋다.
반면, 정적 라이브러리는 실행 파일 크기가 커지지만 실행 시점에 로드할 필요가 없기 때문에 실행 속도가 빠른 경우 사용하면 좋다.

실행 시점에 로드하면, 실행 파일이 실행되기 전에 필요한 라이브러리를 메모리에 로드해야 하기 때문에 실행 시점에 시간이 소요될 수 있다.
또한, 실행 시점에 로드되는 라이브러리는 여러 개의 프로세스가 공유하는 경우, 여러 개의 프로세스가 동시에 라이브러리를 로드하려 할 때 라이브러리를 로드하는데 추가적인 시간이 소요될 수 있다.
반면, 정적 라이브러리는 컴파일 시점에 로드되어 실행 시점에 로드할 필요가 없기 때문에 실행 시점에 시간이 소요되지 않는다.
##############
#this will detect your library.a file and include it during compiling.
#so , cc &(CFLAGS) &(INCLUDE) -L. &(OBJS)
#ar -rcs &(NAME)
**************************************************************
#target … : prerequisites …
#        recipe
#A target is usually the name of a file that is generated by a program; examples of targets are executable or object files. A target can also be the name of an action to carry out, such as ‘clean’ (see Phony Targets).

#A prerequisite is a file that is used as input to create the target. A target often depends on several files.

#A recipe is an action that make carries out. A recipe may have more than one command, either on the same line or each on its own line. Please note: you need to put a tab character at the beginning of every recipe line! This is an obscurity that catches the unwary. If you prefer to prefix your recipes with a character other than tab, you can set the .RECIPEPREFIX variable to an alternate character (see Special Variables).
all: subsystem $(NAME)

subsystem:
#	cd libft; $(MAKE)
#	cd libft && $(MAKE)
	cd libft; make all
#$(make) = make 매크로인듯.
$(NAME):
##	$(CC) $(CFLAGS) $(INCLUDE) $(SRCS)
#	ls -l 
#	@echo "NO ar"
##	ar rc $@ $(OBJS) and later whter ar -rcs change to : ar -rus	$@ $(wildcard *.o)
#	@echo "libftprintf.a"
#	ar -t libft/libft.a = this will list all the compiled files in libft.a := ls function
##	ar -xv libft/libft.a //////////------중요한 단점이 이러면 .h파일 까지 포함해지지 않기때문에 나중에 컴파일시 라이브러리를 불러서 사용할수 없다고 뜸. 그래서 컴파일이 안됌.
#-x extract .o file from .a file.
##	ls -l 
#	@echo "extract"
##	$(CC) $(CFLAGS) $(INCLUDE) $(SRCS)
##	ar -rus	$@ $(OBJS)
#	@echo "done"
#ranlib $@
#--------------------------위에꺼 무용지물이었음.ㅋㅋ


# -----------tester로 넘어갈때 .o인식이 안되서, .a파일을 아에 옮겨서 업데이트시키는 방식으로. 밑의 예와 같음.
#	mv ./libft/libft.a ./$(NAME) 
#	mv = when you make file again after make all, it will recreate .o file again to make libft.a as it moved out, so it doesnt exit any more.
#so you should use cp origin different name.
	cp ./libft/libft.a ./$(NAME) 
	$(CC) $(CFLAGS) $(INCLUDE) $(SRCS)
	ar -rus $@ $(OBJS)

clean:
	make -C ./libft clean
#	rm -rf $(OBJS) 인식이 안되서 안지워짐. 이미 .o파일만 있기에
	rm -rf $(ALL)

fclean: clean
	make -C ./libft fclean
	rm -rf $(NAME)
#	cd ./libft; make fclean

re: fclean all

.PHONY: all clean fclean re libft


#-------------------------------------------------------------------------------------------
#you can do it as copy or mv the libft.a from the folder and add it.

#NAME = libftprintf.a
#SRCS = ft_printf.c ft_printf_utils.c ft_printf_ptr.c ft_printf_hex.c
#OBJS = $(SRCS:.c=.o)
#INCLUDE = libft/libft.h
#CFLAGS = -c -Wall -Wextra -Werror

#all: $(NAME)

#$(NAME):
#	make -C ./libft all 
# = cd libft; make all = cd libft; $(MAKE)
#	make -C ./libft bonus
#	mv ./libft/libft.a ./$(NAME)
#	cc $(CFLAGS) $(SRCS) -I $(INCLUDE)
#	ar -rus $(NAME) $(OBJS)

#clean:
#	make -C ./libft clean
#	rm -f $(OBJS) $(BONUS_OBJS)

#fclean: clean
#	make -C ./libft fclean
#	rm -f $(NAME)
#	rm -f libft.a

#re: fclean all

#.PHONY: all clean fclean re libft
