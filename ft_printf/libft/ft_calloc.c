/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_calloc.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sukwon <sukwon@student.hive.fi>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/11/07 11:20:52 by sukwon            #+#    #+#             */
/*   Updated: 2022/11/22 22:34:49 by sukwon           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	*ft_calloc(size_t count, size_t size)
{
	void	*ptr;
	
	/*if(size == 0 || count == 0)
	{
		ptr = malloc(0);
		if(!ptr)
			return(0);
		return (ptr);
	}
	if(size > 0 && count > 0)
		if((count * size) % count != 0 || (count * size) % size != 0)
			return(NULL)
		정확히 필요가 굳이 없는거 같은데.
		애초에 제가 찾아본봐로는 캘록자체가 오버플로우가 되면 맬록자체가 안되서 
		NULL 이 반환이 되는것이고 그외의 것들은 따로 지정된 행동으로 만들어져있지않아서 
		오버플로우나 인수가 0으로 들어오는 경우자체를 생각안해도 될거 같더라구요. 
		애초에 맬록을 불러와서 쓰는거라 소수점 자체도 생각안해도 될거같고... 
		근데 해주고 싶다면 https://drj11.wordpress.com/2008/06/04/calloc-when-multiply-overflows/ 
		여기 참고하시면 될거같아요 ..ㅎㅎ

		사실 캘록은 전에 큰 메모리 할당이 가능한 컴퓨터는 size_t *size_t
		즉, 총합은 수를 다를수있는 수가 넘어 할당이 되는건데, 할당이 되었다.
		캘록은 size_max 보다 더 많이 할당이 가능하지만 맬록은 불가능.
		관련해서는 https://stackoverflow.com/questions/52699574/can-calloc-allocate-more-than-size-max-in-total
		참고하삼.
		*/
		
	ptr = malloc(count * size);
	if (!ptr)
		return (0);
	ft_bzero(ptr, count * size);
	return (ptr);
}
//따라서 애초에 얘는 
/*이것은 n×s 크기의 블록을 할당하는 것과 동일합니다. 그렇다면 대신 malloc(n*s) 로 이동하는 것이 어떻습니까? 음, 우선 calloc은 메모리를 모두 0으로 초기화하지만 지금은 그것에 대해 신경쓰지 않습니다. malloc(n*s)의 문제점은 제품 nxs가 오버플로될 수 있다는 것입니다.

맬록(65537*65537)

대부분의 32비트 플랫폼에서 이는 32비트 산술 연산을 오버플로하고 자동으로 malloc(131073)과 동일합니다. 그것은 문제입니다.

calloc은 제품의 요소를 넘기기 때문에 원칙적으로 제품을 사용하기 전에 제품이 오버플로되는지 확인하기 위해 요소를 테스트할 수 있습니다. n×s가 오버플로되는 경우 완전히 잘못된 크기의 블록을 할당하는 대신 단순히 할당에 실패할 수 있습니다(NULL 반환).

표준이 이 영역에서 구현에 많은 여유를 제공한다고 생각하지 않습니다.

"널 포인터 또는 할당된 공간에 대한 포인터를 반환합니다", 
암시된 필수 크기가 size_t 또는 이와 유사한 것을 초과하는 경우 정의되지 않은 동작에 대해서는 아무 것도 없습니다. 그러나 진지한 C 프로그래머라면 calloc이 오버플로 사례를 포착하는 데 필요하다고 생각하지 않을 것이라고 생각합니다. 확실히 예상하지 못했고 좋은 일이라고 생각합니다*/